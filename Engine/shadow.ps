Texture2D shaderTexture : register(t0);
Texture2D depthMapTexture : register(t1);

SamplerState SampleTypeClamp : register(s0);
SamplerState SampleTypeWrap  : register(s1);


cbuffer LightBuffer{
	float3 alc;
	float ali;
	float3 dlc;
	float dli;
	float3 slc;
	float sli;
    float4 lightPosition;
	float4 ePos;
};


struct PixelInputType{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
	float4 worldPosition : REKT;
    float4 lightViewPosition : TEXCOORD1;
    float3 lightPos : TEXCOORD2;
};


float4 ShadowPixelShader(PixelInputType input) : SV_TARGET{

    float bias;
    float4 colour;
    float2 projectTexCoord;
    float depthValue;
    float lightDepthValue;
    float lightIntensity;

    bias = 0.005f;

	colour = shaderTexture.Sample(SampleTypeWrap, input.tex);	//@TODO REMEMBER TO += BELOW
    colour += float4(alc * ali, 1.0f);



	//lightViewPosition is actually the screen position of pixels relative to the light source
	///and we just replicate the same procedure that the usual position would go through when being prepared for the fragment shader
    projectTexCoord.x =  input.lightViewPosition.x / input.lightViewPosition.w / 2.0f + 0.5f;
    projectTexCoord.y = -input.lightViewPosition.y / input.lightViewPosition.w / 2.0f + 0.5f;

	
    if((saturate(projectTexCoord.x) == projectTexCoord.x) && (saturate(projectTexCoord.y) == projectTexCoord.y)){

        // check the value of the depth map (basically distance between nearest object and light source) at each of the pixels withing the light's view
        depthValue = depthMapTexture.Sample(SampleTypeClamp, projectTexCoord).r;

		//Now that we have the depth of the object for this pixel we need the depth of the light to determine if it is in front or behind the object.
		//We get this from the lightViewPosition. 
		//Note that we need to subtract the bias from this or we will get the floating point precision issue.

        // Calculate the distance between the pixel (as viewed from the light source) and the light source
        lightDepthValue = input.lightViewPosition.z / input.lightViewPosition.w;

        // Subtract the bias from the lightDepthValue. This mitigates floating point precision issues.
        lightDepthValue = lightDepthValue - bias;
		
		//Now we perform the comparison between the two distances.
		//If the light is close to the pixel position (no objects in between) then it's not shaded (because it's exposed to the light!)
		//But if the there is an object between the light and this pixel (we check this in the depth map) we must shade it

        if(lightDepthValue < depthValue){

            lightIntensity = saturate(dot(input.normal, input.lightPos));

            if(lightIntensity > 0.0f){
                colour += float4(dlc * dli, 1.0f);
                colour = saturate(colour);
            }

			float3 inverseLightDir = input.lightPos - input.worldPosition;
			float dFactor = saturate(dot(input.normal, inverseLightDir));
			float4 diffuse = float4(dlc, 1.0f) * dli * dFactor;
			colour += diffuse;

			float facing = dFactor > 0.0001f ? 1.0f : 0.0f;
			float4 pToEye = normalize(ePos - input.worldPosition);
			float SpecularPower = 64.f;

			float3 halfVector = normalize(inverseLightDir + pToEye.xyz);
			float sFactor  = pow( max( dot(input.normal.xyz, halfVector), 0.0f ), SpecularPower );

			float4 specular = float4(slc, 1.0f) * sli * sFactor;	
			colour += saturate(specular);
        }
    }


    //colour = colour * texturecolour;
    return colour;
}
