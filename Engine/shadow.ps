Texture2D shaderTexture : register(t0);
Texture2D depthMapTexture : register(t1);

SamplerState SampleTypeClamp : register(s0);
SamplerState SampleTypeWrap  : register(s1);


cbuffer LightBuffer{
	float3 alc;
	float ali;
	float3 dlc;
	float dli;
	float3 slc;
	float sli;
    float4 lightPosition;
	float4 ePos;
};


struct PixelInputType{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
	float4 worldPosition : REKT;
    float4 fragPosLightSpace : TEXCOORD1;
    float3 lightPos : TEXCOORD2;
};


float3 applyFog(in float3  rgb,		// original color of the pixel
               in float distance,	// camera to point distance
               in float3  rayDir,   // camera to point vector
               in float3  sunDir )  // sun light direction
{
    float fogAmount = 1.0 - exp( -distance * 0.01f );	//*b WHAT THE HELL IS "b" IN DENSITY MR QUILEZ???
    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );
    float3 fogColor  = lerp( float3(0.5,0.6,0.8), // bluish
                            float3(1.0,0.9,0.7), // yellowish
                            pow(sunAmount,8.0) );
    return lerp( rgb, fogColor, fogAmount );
}


float4 ShadowPixelShader(PixelInputType input) : SV_TARGET{

    float4 colour;
    float2 projectTexCoord;
    float closestDepth;
    float lightDepthValue;
    float lightIntensity;

	input.normal = normalize(input.normal);

    float bias = 0.00001f;

	colour = shaderTexture.Sample(SampleTypeWrap, input.tex);

	//fragPosLightSpace is actually the screen position of pixels relative to the light source
	///and we just replicate the same procedure that the usual position would go through when being prepared for the fragment shader
    projectTexCoord.x =  input.fragPosLightSpace.x / input.fragPosLightSpace.w / 2.0f + 0.5f;
    projectTexCoord.y = -input.fragPosLightSpace.y / input.fragPosLightSpace.w / 2.0f + 0.5f;

	
    if((saturate(projectTexCoord.x) == projectTexCoord.x) && (saturate(projectTexCoord.y) == projectTexCoord.y)){

        closestDepth = depthMapTexture.Sample(SampleTypeClamp, projectTexCoord).r;

        //lightDepthValue = ( (2.f * input.fragPosLightSpace.z - 500.01f ) / 499.99f ) / input.fragPosLightSpace.w;
		lightDepthValue = input.fragPosLightSpace.z / input.fragPosLightSpace.w;	// input.fragPosLightSpace.w

        lightDepthValue -= bias;

        if(lightDepthValue > closestDepth){

			colour -= float4(alc * ali, 1.0f);
		}
    }

	colour += saturate(float4(alc * ali, 1.0f));

	float3 inverseLightDir = normalize(input.lightPos - input.worldPosition);
	float dFactor = saturate(dot(input.normal, inverseLightDir));
	float4 diffuse = saturate(float4(dlc, 1.0f) * dli * dFactor);
	colour += diffuse;
	
	//some setup for specular
	float facing = dFactor > 0.0001f ? 1.0f : 0.0f;
	float4 pToEye = ePos - input.worldPosition;
	float pToEyeDist = length(pToEye);
	pToEye = pToEye/pToEyeDist;
	float SpecularPower = 16.f;

	//specular light phong
	float3 reflectionVector = 2 * dot( input.normal, inverseLightDir.xyz ) * input.normal - inverseLightDir.xyz;
	//float3 reflectionVector = reflect(input.normal, inverseLightDir.xyz);
	float sFactor = saturate(dot(reflectionVector, pToEye.xyz));
	sFactor = pow(sFactor, SpecularPower);

			
	//specular light blinn-phong 
	float3 halfVector = normalize(inverseLightDir + pToEye.xyz);
	sFactor  = pow( max( dot(input.normal.xyz, halfVector), 0.0f ), SpecularPower );
			

	float4 specular = float4(slc, 1.0f) * sli * sFactor;	
	colour += saturate(specular);

	//applying fog in the postprocess is probably going to give the best result
	//colour = float4(applyFog(colour, pToEyeDist, -pToEye, -inverseLightDir), 1.0f);
    return colour;
}
